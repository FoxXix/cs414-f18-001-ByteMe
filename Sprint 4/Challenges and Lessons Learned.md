# Challenges and Lessons Learned: Team ByteMe

## Challenges:
Throughout the development process, there were a number of challenges that came up for the team.  Some of these were related to understanding the material of the course as it applied to this project and others were related to figuring out how to implement the system itself.

This project was just as much about writing source code as it was documenting it.  It was a challenge getting used to that development style, because in previous CS courses, it's all pretty much been about writing the code and not diagraming it and explaining how everything in the system works together to meet the goals of the client.  Additionally, the specification for the deliverables was often hard to follow to the point where the team missed expectations, simply because in reading the specification it was not evident.

When the team was first given the project, it was challenging to complete so many documents before really writing the code.  Since this was a different method of developing a project than the way the team members are used to, many of the concepts, use cases and models changed significantly with each iteration.  This posed a challenge, in that it with each iteration, the team had to rethink these documents, models and sometimes the source code and weigh what the best solution might be.

A big challenge at the end of the semester was getting the two users / computers to communicate with each other, especially for game play.  Luckily one of the team members had experience with and previous code written for message passing that could be adapted.  However, while most of these tasks got done eventually, the hardest part of this was facilitating game play between two devices.  The game would appear on one device and moves could be made, but the other device (the one that initiated the game) could not see, access or play on the board.  These features were fairly well established to work on a single device, but that was no longer functional when the request came in to allow play on two different devices.

The biggest challenge however, was working as a group of 3 to complete the amount of work set for 5-6 group members.  In this sense, each group member was required to do much more individually than they originally anticipated, because after the first iteration of this project, two of the group members dropped out.  There were also a number of features that could not be implemented, for there were not enough resources to complete them.  It was expressed that the standards were lowered for this team, because there were less developers, but it always felt like other teams were getting to bigger and more advancced features, solely because they had more people working to complete their game systems.

# Lessons Learned:
1) The course requirements for the project changed from what the team was expecting initally (i.e. the new request for a two-computer demo), but so is the case in industry.  The team learned how to adapt accordingly to this change and these types of changes, which can commonly occur when the client's needs and expectations are not solidified until the product is complete.
2) The requirements for any software project, when they come from a client, can often be ambiguous, so not all features and functionality will be completely clear to the developers.
3) Through having a smaller than average group, the team was faced with prioritizing some of the deliverables over others, to meet as many of the requirements as possible.  The lesson here was that there are times when not everything can get done by a deadline, due to factors outside of the team's control.
4) The team members learned how to work to collectively to accomplish the goal of implementing the Banqi Game.
5) Working as a team is effective not only because it allows for the completion of bigger projects, but also because each individual member has their own skillsets, so that when working as a group, more knowledge bases are covered.
6) Implementing refactoring operations and design patterns is trickier after the code has been written, rather than doing it from the start.  The lesson here is that in software development, it's better to account for as many of these software patterns and principles early on to make a smoother development process.
